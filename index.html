<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>libsodium</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
          <textarea data-template>
            ## Needs more salt...
            ### Password hashing and why you should care about libsodium

            <img src="img/saltshaker.jpg" alt="" style="width: 25%;">

            By: Garrett Rappaport

          </textarea>
        </section>
        <section data-markdown>
          <textarea data-template>
            ## whoami

            * Backend Engineer @ ShootProof
            * Avid table-top gamer, Musician, Geek Orthodox
            * On the interwebs: syntacticNaCl (twitter, IRC Freenode, keybase, etc)
            * PGP fingerprint: [006D-AEF3-307B-8D22-0109-8B32-7EC3-55D1-CBC7-123C](https://keybase.io/syntacticnacl)
          </textarea>
        </section>
        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## agenda

            * Password hashing algorithms
            * Password best practices
            * libsodium
            * Password hashing with libsodium
            * Encryption with libsodium
            * Encryption best practices
            * Demo Argon2i
            * Demo Encrypt/Decrypt with libsodium

            Note:
            * Quick show of hands
            * Who has implemented some form of password hashing or encryption in an application?
            * Who has heard of libsodium?
          </textarea>
        </section>
        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## Disclaimer

            I am not:
            * A cryptographer by trade
            * An expert in cryptography

            Note:
		        * Cryptography is just fascinating
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## Let's talk about salt

            <img src="img/saltshaker2.jpg" alt="" style="width: 25%;">
            Note:
		        * Not that kind
          </textarea>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## NaCl

              * NaCl - Pronounced "salt"
              * Networking and Cryptography library

              Note:
              * NaCl is a cryptographic library
              * Stands for Networking and Cryptography library
              * NaCl is the chemical forumula for Sodium Chloride or Salt
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
                ## NaCl: Goal

                > ... to provide all of the core operations needed to build higher-level cryptographic tools
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## What is libsodium?

              * Sodium is a modern, easy-to-use software library for encryption, decryption, signatures, password hashing, and more.
              * Audited and verified

              Note:
              * Fork of NaCl with a compatible API and some extensions to improve usability even further
              * IMPORTANT: Audited and verified
              * Bindings for many languages including PHP, Python, GO, etc
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## libsodium goal

              > ... to provide all of the core operations needed to build higher-level cryptographic tools
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
              ## libsodium audit

              >... We are pleased to report that our review did not uncover any critical flaws or vulnerabilities in the core library. Overall we believe that libsodium is a carefully-implemented, secure cryptographic library.‚Äù

              Note:
              libsodium has been audited by request of privateinternetaccess.com VPN service
              audited by Dr. Matthew Green and team at cryptoengineers.com
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            ## libsodium in PHP

            Supported as of PHP 7.2.0 and newer

            Compile PHP with libsodium, install via PECL, or OS package manager

            <pre>
              <code data-trim data-noescape>
                --with-sodium
	            </code>
            </pre>
          </textarea>
          </section>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## I Care Why?

            <img src="img/stop.gif" alt="" style="width: 50%;">

            Note:
            * Before we dive into libsodium lets discuss some password hashing basics
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## !Password encryption

            Say it with me...

            > Passwords should NOT be encrypted!

            Note:
            * This is a bit of a misnomer... A lot of hashing algorithms use encryption in them
            * The important part is that the stored value should be one-way, infeasible to invert
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## Password hashing

            You should never ever, ever, ever need to decrypt a password

            Note:
            * Passwords should be hashed
            * The point of password hashing algorithms is to make it too computationally expensive for an attacker to crack a hash,
            while making it not too expensive for hash creation
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
            ## Let's take a brief trip

            Down password hashing memory lane...

            <img src="img/base64_a_password.png" alt="" style="width: 50%;">

            Note:
            * Widely used password hashing functions and algorithms in PHP
              * MD5
              * bcrypt
              * Argon2
          </textarea>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## MD5 hashing function

            * Pros:
              * It's really fast
              * Useful for checksum verification (unintentional corruption)
            * Cons:
              * It's really fast
              * Incredibly Vulnerable to hash collisions
              * GPU's render (hehe) MD5 unbelievably broken

            Note:
            * Originally designed as a cryptographic hash function
            * Incredibly vulnerable due to hash collisions
              * Hash collisions are when you can find pairs of distinct inputs which hash to the same value
            * Especially vulnerable to GPU cracking due to the nature of the algorithm
              * Can easily optimize a GPU to crack MD5 efficiently
            * Best used for checksums to verify data integrity, but only against uintentional corruption. NOT intentional tampering
            * MD5's ultimate downfall is that it is too fast and that it is not configurable
            * You are also dealing with an entropy problem
              * Remember entropy is not length, it is the use of characters that are unknown to the attacker
              * Length of a password plays a very small role in how safe it is
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
            ## MD5 passwords

              <pre>
                <code data-trim data-noescape>
                  // NOOOOOOO!!!
                  $hash = md5($password);
	              </code>
              </pre>
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
            ## MD5 passwords w/ static "salt"

              <pre>
                <code data-trim data-noescape>
                  // STILL NOOOOOOO!!!
                  $hash = md5($password . $salt);
	              </code>
              </pre>
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## MD5 passwords w/ unique "salt"?

              <pre>
                <code data-trim data-noescape>
                  // OOOH fancy... STILL NOOOOOOO!!!
                  $hash = md5($password . $salt . strtolower($email));
	              </code>
              </pre>
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
            ## MD5 hashing passwords

            <img src="img/office-no.gif" alt="" style="width: 50%;">
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## Its not just MD5...

            * General purpose hashing algorithms are bad choices in general for passwords
            * This includes MD5, SHA1, SHA2, etc

            Note:
            * Technically MD5 and SHA1 aren't weaker than SHA-2 in regards to password hashing
            * All of these functions are in comparison really fast and rely on the entropy of the password input
            * Relying on the entropy of a user's password is not smart
            * Hardware is able to try billions of passwords per second! and that is only with a few GPUs
            * We need hashing functions that are deliberately slow and password hardened such as:
              * bcrypt, scrypt, or PBKDF2
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## bcrypt hashing function

            * Resistant to rainbow table attacks due to use of salt
            * Configurable

            Note:
            * Allows for increasing cost
            * Cons
              * Low, constant memory usage
              * Vulnerable to cost-effective brute-forcing
                * Using Field Programmable Gate Arrays or FPGAs
                * Or a distributed network of CPU or GPU based "crackbots"
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## bcrypt hash breakdown
              <pre>
                <code data-trim data-noescape>
                  <mark>$2y$10</mark>$5ueXbCtUXb8mQFGoCnzvMObnyOwauldtMO4UTsDg6P6n6Xk2QghEu
                </code>
              </pre>

              * $2y$ - Blowfish-based crypt format
              * 10$ - cost
              * 5ueXbCtUXb8mQFGoCnzvMO - encoded salt
              * bnyOwauldtMO4UTsDg6P6n6Xk2QghEu - encoded hash

              Note:
              * Cryptographers got smarter and started storing configuration values in the hash itself
                * No longer have to pull from different storage mediums to access information about the hash
                * Makes hash easier to verify in one fail swoop since what is need is in the hash itself
              * Allows for increasing cost - which represents a key expansion iteration count
              * All pieces add up to an encoded 60 character string
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## bcrypt in PHP

              * PHP < 5.3.7 you had to use the `crypt()` function
              * PHP >= 5.3.7 and < 5.5-DEV you had to use a compatibility library `ircmaxell/password_compat`
              * PHP >= 5.5-DEV introduced `password_hash()`

              <img src="img/lotr-ring.jpg" alt="" style="width: 25%;">

              Note:
              * The one PHP password hashing function to rule them all
              * One ring to find them... ok sorry, lets move on
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## Argon2

            * Winner of Password Hashing Competition (PHC) in July 2015
            * Variable-length hash function
            * Internally built on Blake2
            * Can produce digests up to 2^32 bytes long
            * 3 variations
              * Argon2d
              * Argon2i
              * Argon2id
            * Still technically in draft status with the IRTF

            Note:
            All three modes allow specification of three parameters that control:
            * execution time
            * memory required
            * threads - or degree of parallelism
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## Argon2d

            * Maximizes resistance to GPU cracking attacks
            * Accesses memory array in password dependent order
            * Resistant to time-memory trade-off (TMTO) attacks
            * Possibility of side-channel attacks

            Note:
            * Argon2d maximizes resistance to GPU cracking attacks.
            * Accesses memory array in password dependent order
            * Dependent refers to dependency on the password itself. This prevents prefetching and precomputing missing data, thus the increased resistance to TMTO attacks
            * This means the computation happens at the time the element is needed
            * Conversely, this introduces the possibility of side-channel attacks since timing information based on when the computation happens can help filter out password guesses
            * In the wild it is typically used for crytocurrency and other applications with no threats from side-channel attacks
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## Argon2i

            * Optimized to resist side-channel attacks
            * Accesses memory array in password independent order

            Note:
            * Argon2i is optimized to resist side-channel attacks.
            * Accesses memory array in password independent order
            * Independent refers to independent of the password and salt, but possibly dependent on other public parameters
            * Because of this, TMTO attacks are more feasable since precomputation is possible
            * Side-channel attacks are the weaker link of the two main attacks
            * It accesses the memory array in a password independent order.
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## Argon2id

            * Recommended variation
            * Hybrid of Argon2i and Argon2d
            * It follows the Argon2i approach for the first pass over memory and the Argon2d approach for subsequent passes.
            * This makes it more resistant to both TMTO and side-channel attacks

            Note:
            * Argon2id is a hybrid version.
            * It follows the Argon2i approach for the first pass over memory and the Argon2d approach for subsequent passes.
            * Recommend using Argon2id except when there are reasons to prefer one of the other two modes.
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## argon2id hash breakdown
              <pre>
                <code data-trim data-noescape>
                  $argon2id$v=19$m=1024,t=2,p=2$bmtTVmlKMFVyWnMuYWtkZA$oZKud4eOmRKxz8x2HizDzA04Abc5TyMBDHCGqDgkXgI
                </code>
              </pre>

              * argon2id - variant
              * v=19 - version
              * m=1024 - memory size in kibibytes
              * t=2 - iterations
              * p=2 - parallelism
              * $bmt... - base-64 encoded salt
              * $oZK... - base-64 encoded hash

              Note:
              * Cryptographers got smarter and started storing configuration values in the hash itself
                * No longer have to pull from different storage mediums to access information about the hash
                * Makes hash easier to verify in one fail swoop since what is need is in the hash itself
              * Allows for increasing cost - which represents a key expansion iteration count
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## argon2 in PHP

              * Argon2i - available as of PHP 7.2
              * Argon2id - available as of PHP 7.3
              * PHP must be compiled with Argon2 support or installed with OS package manager

              <pre>
                <code data-trim data-noescape>
                  --with-password-argon2=/usr
                </code>
              </pre>

              Note:
              * PHP must be compiled with Argon2 support
              * Again Argon2id is recommended
            </textarea>
          </section>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
          ## Side-channel attack

          * Based on "side channel information"
          * Attackers gather specific information about the device used to encrypt the message
          * Information regarding:
            * timing
            * radiation, heat
            * power consumption
            * and more

          Note:
          * Side channel attacks use information that does not relate to the plaintext or ciphertext
          * Interesting attack example not directly related to hashing
          * *Anecdote* interesting attacks executed by researchers at the Technion in Israel against airgapped computers
            * Able to successfully send commands from a computer on the web to an airgapped computer located next to it
            * Done using the sending of signals based on raising and lowering temperatures on the non-airgapped computer
          * There are similar attacks using other electro magnetic signals
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
          ## TMTO attack

          * All about "trade-offs":
          * Shortening running time by using more space (memory)
          * Improves (memory) usage by adding more computing time
          * Rainbow tables
          * Difficult to attack successfully

          Note:
          * Generic terminology for an algorithm that either improves running time by using more memory or improves memory usage by using more computing time
          * Rainbow tables sit between:
            * Precomputed table containing hashes of potention passwords
            * Exhaustive search of trying all potential passwords
          * This balancing act allows for narrowing down the possibility of discovering the hash
          * Salts can be used to thwart precomputed tables, including rainbow tables
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
          ## Salts

          * Salts should be as unique as possible
          * Reusing salts is a BAD idea

          Note:
          * Salts should be unique
          * Salts don't NEED to be secret, but they also don't NEED to be public
          * Salts should NOT be things like emails or usernames since even changing the password will keep the same salt
          * Remember, users tend to re-use passwords all over the internet, especially incremental ones, BobsPassword1, BobsPassword2, etc
          </textarea>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Hashing in libsodium

              * Password hashing - `crypto_pwhash()`
              * Generic hashing - `crypto_generichash()`
              * Short hashing - `crypto_shorthash()`

              Note:
              * Password hashing - Secure password storage, key derivation from user input
              * Generic hashing - It is collision and preimage-resistant; replace MD5/SHA1/etc.
              * Short hashing - Hash tables, bloom filters, cache lookup keys
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Creating a password hash in libsodium

              * sodium_crypto_pwhash_str()

              <pre>
                <code data-trim data-noescape>
                  $hash = sodium_crypto_pwhash_str(
                      $password,
                      SODIUM_CRYPTO_PWHASH_OPSLIMIT_INTERACTIVE,
                      SODIUM_CRYPTO_PWHASH_MEMLIMIT_INTERACTIVE
                  );
                </code>
              </pre>

              Note:
              * Hashes are calculated using the Argon2id algorithm
              * In contrast to the password_hash function, there is no salt parameter (salt is generated automatically)
              * opslimit and memlimit parameters are not optional
              * These limits are on the lower end and only require 64MiB of dedicated RAM
              * There is also
                * SODIUM_CRYPTO_PWHASH_OPSLIMIT_MODERATE
                * SODIUM_CRYPTO_PWHASH_OPSLIMIT_SENSITIVE
              * These require increased memory and cpu requirements
              * All on libsodiums documentation
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Verifying a password hash in libsodium

              * sodium_crypto_pwhash_str_verify()

              <pre>
                <code data-trim data-noescape>
                  $verified = sodium_crypto_pwhash_str_verify(
                      $hash,
                      $password,
                  );
                </code>
              </pre>

              Note:
              * Same opslimit and memlimit parameters should be used
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## PHP core figured it out

            * [password_get_info](https://php.net/manual/en/function.password-get-info.php) ‚Äî Returns information about the given hash
            * [password_hash](https://php.net/manual/en/function.password-hash.php) ‚Äî Creates a password hash
            * [password_needs_rehash](https://php.net/manual/en/function.password-needs-rehash.php) ‚Äî Checks if the given hash matches the given options
            * [password_verify](https://php.net/manual/en/function.password-verify.php) ‚Äî Verifies that a password matches a hash

            Note:
            * No need for special password hashing implementations
            * These are all you need
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## password_get_info

              <pre>
                <code data-trim data-noescape>
                    password_get_info ( string $hash ) : array

                    /* returns:
                    Array (
                        [algo] => 1
                        [algoName] => bcrypt
                        [options] => Array ( [cost] => 11 )
                    )
                    */
	              </code>
              </pre>

              Note:
              * Returns information about the given hash
              * When passed in a valid hash created by an algorithm supported by password_hash(),
                this function will return an array of information about that hash.
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## password_hash

              <pre>
                <code data-trim data-noescape>
                  password_hash ( string $password , int $algo [, array $options ] ) : string
                </code>
              </pre>
              Note:
              * Creates a password hash
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## password_hash algorithms

              * PASSWORD_DEFAULT - Uses the bcrypt algorithm (default as of PHP 5.5.0)
              * PASSWORD_BCRYPT
              * PASSWORD_ARGON2I
              * PASSWORD_ARGON2ID

              Note:
              * Creates a password hash
              * Note regarding storing password hashes. If you use PASSWORD_DEFAULT, please take into account the length of the digest which could increase over time. 255 characters should be enough for most if not all digests
              * Probably good advice for all uses of password_hash(). That way you can upgrade hashes at any time using the password_needs_rehash() check + password_hash()
              * PASSWORD_DEFAULT - Use the bcrypt algorithm (default as of PHP 5.5.0). Note that this constant is designed to change over time as new and stronger algorithms are added to PHP. For that reason, the length of the result from using this identifier can change over time. Therefore, it is recommended to store the result in a database column that can expand beyond 60 characters (255 characters would be a good choice).
              * PASSWORD_BCRYPT - Use the CRYPT_BLOWFISH algorithm to create the hash. This will produce a standard crypt() compatible hash using the "$2y$" identifier. The result will always be a 60 character string, or FALSE on failure.
              * PASSWORD_ARGON2I - Use the Argon2i hashing algorithm to create the hash. This algorithm is only available if PHP has been compiled with Argon2 support.
              * PASSWORD_ARGON2ID - Use the Argon2id hashing algorithm to create the hash. This algorithm is only available if PHP has been compiled with Argon2 support.
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## password_hash options

              * PASSWORD_BCRYPT - options available `cost`
              * PASSWORD_ARGON2I - options available `memory_cost`, `time_cost`, `threads`
              * PASSWORD_ARGON2ID - options available `memory_cost`, `time_cost`, `threads`

              Note:
              * Creates a password hash
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## password_hash option defaults

              * Memory and Parallelism or threads - set is as high as you can comfortably support
              * Iterations - Start with a low value (10) and move up from there

              Note:
              * Largely dependent on server hardware
              * Iterations requires some testing.
              * Run some benchmarks on your system and see what works for you
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## password_needs_rehash

            <pre>
              <code data-trim data-noescape>
                password_needs_rehash ( string $hash , int $algo [, array $options ] ) : bool
              </code>
            </pre>

            Note:
            * Checks if the given hash matches the given options
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
            ## password_verify

            <pre>
              <code data-trim data-noescape>
                  password_verify ( string $password , string $hash ) : bool
              </code>
            </pre>

            Note:
            * Verifies that the given hash matches the given password
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## password_verify when using salts

              * Rehashing a password using password_hash will yield a different digest due to random salts
              * Must use `password_verify()`

              Note:
              * No more hash(password) === hashedPassword
            </textarea>
          </section>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Many algorithm, what do?

              * Bcrypt
              * Argon2

              Note:
              * Bcrypt is solid when configured with the correct parameters
              * Argon2 is better but still needs time to prove itself
                * It has been almost 4 years since winning PHC
                * That is a good amount of time but use at your own risk
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Many function, what do?

              * password_hash() vs sodium_crypto_pwhash_str()

              Note:
              * They both accomplish largely the same goal
              * The important part is that they are used responsibly
              * DO NOT use your own salt unless you know what you are doing, just let it generate it for your
              * sodium_crypto_pwhash_str_verify doesn't allow for manual salt creation and enforces a default limit for opslimit and memlimit
              * password_hash() also takes similar parameters so you can use it responsibly as well
              * Use what you want, but be smart about it
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Encryption

              <img src="img/encrypt-all.png" alt="" style="width: 25%;">

              Note:
              * Before we get into encryption with libsodium, lets clarify some important concepts
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Encryption vs Authenticated Encryption

              * Why is this important?
              * Why does the order of authentication and encryption matter?

              Note:
              * Encryption renders the message unreadable without the correct key
              * Authentication makes a message tamper-resistant
              * When I use the word authentication it refers to the authenticity of the message not the authentication of an identity
              * ParagonIE's blog uses these descriptions which I found really helpful
                * Encryption does not provide integrity
                * Authentication does not provide confidentiality
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Why is Authenticated Encryption important

              * Prevents bit-rewriting/bit-flipping attacks

              Note:
              * This is where an attacker can change the ciphertext in such a way as to result in a predictable change of the plaintext
              * Authentication allows us to check if any bits were flipped in transit
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## MAC

              * Message Authentication Code

              Note:
              * Short piece of information used to authenticate a message
              * Protects both message's data integrity as well as its authenticity
          </textarea>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Order of operations

              * Always encrypt then MAC!
              * In other words, encrypt then authenticate
              * This allows for authentication then decryption on the other end

              Note:
              * This order allows us to authenticate first then decrypt which can prevent some common attacks like the Vaudenay attack
              * https://moxie.org/blog/the-cryptographic-doom-principle/
              * Vaudenay attack
              * Oversimplified example:
                * Essentially the attacker can modify the last byte in the ciphertext and check for error messages
                  * Doesn't need to be an error message you can typically tell by the timing of the error response
                * Once they receive what would represent an invalid MAC error, they know what the last byte is
                * Rinse and repeat until the ciphertext is decrypted
              * By verifying the MAC first, this attack is not able to be executed
          </textarea>
        </section>

        <section>
          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Libsodium encryption in PHP

              * sodium_memzero()
              * random_bytes()
              * sodium_crypto_secretbox()
              * sodium_crypto_secretbox_open()

              Note:
              * Here are the four functions that you need to know for doing a proper authenticated encryption
              * I am only discussing secret-key authenticated encryption
              * There are others for libsodium regarding public-key cryptography and other cryptographic primitives
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Wiping sensitive data

              <pre>
                <code data-trim data-noescape>
                  sodium_memzero ( string &$buf ) : void
                </code>
              </pre>

              Note:
              * Used to destroy sensitive information like keys, plaintext, and ciphertext
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Generating secure random values

              <pre>
                <code data-trim data-noescape>
                  random_bytes ( int $length ) : string
	              </code>
              </pre>

              * Use random_bytes()
              * Issues in the past with other functions calling userspace CSPRNGs
              * Userspace CSPRNGs are bad

              Note:
              * Uses kernel CSPRNG, not userspace CSPRNG
              * cryptographically secure pseudo-random number generator (CSPRNG)
              * There were some issues in the past with openssl_random_pseudo_bytes()
              * Honestly OpenSSL hasn't had the best track record with security
              * Those issues were rectified I believe, but its safer to just use random_bytes() at this point
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Encryption

              <pre>
                <code data-trim data-noescape>
                  sodium_crypto_secretbox ( string $string , string $nonce , string $key ) : string
	              </code>
              </pre>
              Note:
              * Implements symmetric, or shared-key, authenticated encryption
              * Useful when using a pre-shared key or a negotiated key
              * The same can be done when using a negotiated key, as opposed to a shared-key, via something like Elliptic Curve Diffie-Hellman
            </textarea>
          </section>

          <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
            <textarea data-template>
              ## Decryption

              <pre>
                <code data-trim data-noescape>
                  sodium_crypto_box_open ( string $ciphertext , string $nonce , string $key ) : string
	              </code>
              </pre>

              Note:
              * Decrypts with same nonce and key used in encryption
            </textarea>
          </section>
        </section>

        <section data-markdown data-separator="^\n\n\n" data-separator-vertical="^\n\n" data-separator-notes="^Note:">
          <textarea data-template>
              ## Halite

              * [paragonie/halite](https://github.com/paragonie/halite)

              Note:
              * Halite is a high-level cryptography interface that relies on libsodium for all of its underlying cryptography operations
              * It's just an abstraction of what we did here today
              * ParagonIE is a great resource for using libsodium in PHP and other security topics
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Demo Time

            <img src="img/demo.gif" alt="" style="width: 50%;">

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
            ## Questions???

            <img src="img/questions.gif" alt="" style="width: 50%;">

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
          ## Resources
          * [libsodium Security Assessment](https://www.privateinternetaccess.com/blog/2017/08/libsodium-v1-0-12-and-v1-0-13-security-assessment/)
          * [libsodium docs](https://download.libsodium.org/doc/)
          * [Using libsodium in PHP](https://paragonie.com/book/pecl-libsodium)
          * [NaCl docs](https://nacl.cr.yp.to/)
          * [MD5](https://en.wikipedia.org/wiki/MD5)
          * [bcrypt](https://en.wikipedia.org/wiki/Bcrypt)
          * [Why order of encryption and authentication is important](https://moxie.org/blog/the-cryptographic-doom-principle/)
          * [ParagonIE](https://paragonie.com/blog)
          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
          ## Thanks
          * *IRC Freenode*: syntacticNaCl
          * *Twitter*: @syntacticNaCl
          * *Github*: syntacticNaCl
          * *Email*: garrettrappaport@protonmail.ch
          * *Website*: syntacticnacl.com
          </textarea>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
